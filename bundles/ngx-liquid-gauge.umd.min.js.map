{"version":3,"sources":["ng://ngx-liquid-gauge/lib/ngx-liquid-gauge.service.ts","ng://ngx-liquid-gauge/lib/ngx-liquid-gauge.component.ts","ng://ngx-liquid-gauge/lib/liquidFillGauge.ts","ng://ngx-liquid-gauge/lib/ngx-liquid-gauge.module.ts"],"names":["NgxLiquidGaugeService","Injectable","args","providedIn","NgxLiquidGaugeComponent","Math","floor","random","minValue","maxValue","circleThickness","circleFillGap","circleColor","waveHeight","waveCount","waveRiseTime","waveAnimateTime","waveRise","waveHeightScaling","waveAnimate","waveColor","waveOffset","textVertPosition","textSize","valueCountUp","displayPercent","textColor","waveTextColor","this","defaultSettings","prototype","ngOnInit","createChart","ngOnChanges","changes","element","gauge","nativeElement","d3.select","selectAll","remove","append","attr","id","settings","loadLiquidFillGauge","elementId","value","config","waveHeightScale","radius","min","parseInt","style","locationX","locationY","fillPercent","max","d3.scaleLinear","range","domain","textPixels","textFinalValue","parseFloat","toFixed","textStartValue","percentText","fillCircleMargin","fillCircleRadius","waveLength","waveClipCount","waveClipWidth","textRounder","val","round","data","i","push","x","y","PI","waveScaleX","waveScaleY","waveRiseScale","waveAnimateScale","textRiseScaleY","gaugeGroup","rectpoints","lineFunc","d3.line","d","text1","text","clipArea","d3.area","y0","sin","y1","waveGroup","wave","datum","fillCircleGroup","text2","textTween","_this","d3.interpolate","textContent","t","transition","duration","tween","waveGroupXPosition","animateWave","_","ease","d3.easeLinear","on","GaugeUpdater","update","newFinalValue","textRounderUpdater","val2","newClipArea","newHeight","newWavePosition","liquid.loadLiquidFillGauge","Component","selector","template","ViewChild","Input","NgxLiquidGaugeModule","NgModule","imports","declarations","exports"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class NgxLiquidGaugeService {\r\n\r\n  constructor() { }\r\n}\r\n","import { Component, OnInit, ViewChild, Input, OnChanges, SimpleChanges } from '@angular/core';\r\nimport * as d3 from 'd3';\r\nimport * as liquid from './liquidFillGauge';\r\n\r\n@Component({\r\n  selector: 'lib-ngx-liquid-gauge',\r\n  template: `<div #gauge></div>`,\r\n  styles: []\r\n})\r\nexport class NgxLiquidGaugeComponent implements OnInit, OnChanges {\r\n\r\n  @ViewChild('gauge') gauge: any;\r\n  id = 'gauge' + Math.floor(Math.random() * 100000) + 1; // assign a random ID to SVG component\r\n  private defaultSettings = liquid.liquidFillGaugeDefaultSettings();\r\n  @Input() private value = 0;\r\n  @Input() private minValue = this.defaultSettings.minValue;\r\n  @Input() private maxValue = this.defaultSettings.maxValue;\r\n  @Input() private circleThickness = this.defaultSettings.circleThickness;\r\n  @Input() private circleFillGap = this.defaultSettings.circleFillGap;\r\n  @Input() private circleColor = this.defaultSettings.circleColor;\r\n  @Input() private waveHeight = this.defaultSettings.waveHeight;\r\n  @Input() private waveCount = this.defaultSettings.waveCount;\r\n  @Input() private waveRiseTime = this.defaultSettings.waveRiseTime;\r\n  @Input() private waveAnimateTime = this.defaultSettings.waveAnimateTime;\r\n  @Input() private waveRise = this.defaultSettings.waveRise;\r\n  @Input() private waveHeightScaling = this.defaultSettings.waveHeightScaling;\r\n  @Input() private waveAnimate = this.defaultSettings.waveAnimate;\r\n  @Input() private waveColor = this.defaultSettings.waveColor;\r\n  @Input() private waveOffset = this.defaultSettings.waveOffset;\r\n  @Input() private textVertPosition = this.defaultSettings.textVertPosition;\r\n  @Input() private textSize = this.defaultSettings.textSize;\r\n  @Input() private valueCountUp = this.defaultSettings.valueCountUp;\r\n  @Input() private displayPercent = this.defaultSettings.displayPercent;\r\n  @Input() private textColor = this.defaultSettings.textColor;\r\n  @Input() private waveTextColor = this.defaultSettings.waveTextColor;\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit() {\r\n    this.createChart();\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    this.createChart();\r\n  }\r\n\r\n  createChart(): any {\r\n    const element: Element = this.gauge.nativeElement;\r\n    //clear previous chart\r\n    d3.select(element).selectAll('*').remove();\r\n\r\n    d3.select(element)\r\n      .append('svg').attr('id', this.id)\r\n      .attr('width', '150')\r\n      .attr('height', '150');\r\n    const settings = {\r\n      minValue: this.minValue,\r\n      maxValue: this.maxValue,\r\n      circleThickness: this.circleThickness,\r\n      circleFillGap: this.circleFillGap,\r\n      circleColor: this.circleColor,\r\n      waveHeight: this.waveHeight,\r\n      waveCount: this.waveCount,\r\n      waveRiseTime: this.waveRiseTime,\r\n      waveAnimateTime: this.waveAnimateTime,\r\n      waveRise: this.waveRise,\r\n      waveHeightScaling: this.waveHeightScaling,\r\n      waveAnimate: this.waveAnimate,\r\n      waveColor: this.waveColor,\r\n      waveOffset: this.waveOffset,\r\n      textVertPosition: this.textVertPosition,\r\n      textSize: this.textSize,\r\n      valueCountUp: this.valueCountUp,\r\n      displayPercent: this.displayPercent,\r\n      textColor: this.textColor,\r\n      waveTextColor: this.waveTextColor,\r\n    };\r\n    liquid.loadLiquidFillGauge(this.id, this.value, settings);\r\n  }\r\n\r\n}\r\n","/*!\r\n* Note this was taken from Curtis Bratton's code: http://bl.ocks.org/brattonc/5e5ce9beee483220e2f6\r\n* I upgraded the D3 API and made minor modifications along the way as I converted it to Typescript from Javascript.\r\n* All credits go to Curtis.\r\n* Dayo Adetoye. 2018. https://github.com/adedayo\r\n*/\r\n\r\n\r\nimport * as d3 from 'd3';\r\n\r\n/*!\r\n * @license Open source under BSD 2-clause (http://choosealicense.com/licenses/bsd-2-clause/)\r\n * Copyright (c) 2015, Curtis Bratton\r\n * All rights reserved.\r\n *\r\n * Liquid Fill Gauge v1.1\r\n */\r\nexport function liquidFillGaugeDefaultSettings() {\r\n  return {\r\n    minValue: 0, // The gauge minimum value.\r\n    maxValue: 100, // The gauge maximum value.\r\n    circleThickness: 0.05, // The outer circle thickness as a percentage of it's radius.\r\n    circleFillGap: 0.05, // The size of the gap between the outer circle and wave circle as a percentage of the outer circles radius.\r\n    circleColor: '#178BCA', // The color of the outer circle.\r\n    waveHeight: 0.05, // The wave height as a percentage of the radius of the wave circle.\r\n    waveCount: 1, // The number of full waves per width of the wave circle.\r\n    waveRiseTime: 1000, // The amount of time in milliseconds for the wave to rise from 0 to it's final height.\r\n    waveAnimateTime: 18000, // The amount of time in milliseconds for a full wave to enter the wave circle.\r\n    waveRise: true, // Control if the wave should rise from 0 to it's full height, or start at it's full height.\r\n    // tslint:disable-next-line:max-line-length\r\n    waveHeightScaling: true, // Controls wave size scaling at low and high fill percentages. When true, wave height reaches it's maximum at 50% fill, and minimum at 0% and 100% fill. This helps to prevent the wave from making the wave circle from appear totally full or empty when near it's minimum or maximum fill.\r\n    waveAnimate: true, // Controls if the wave scrolls or is static.\r\n    waveColor: '#178BCA', // The color of the fill wave.\r\n    waveOffset: 0, // The amount to initially offset the wave. 0 = no offset. 1 = offset of one full wave.\r\n    textVertPosition: .5, // The height at which to display the percentage text withing the wave circle. 0 = bottom, 1 = top.\r\n    textSize: 1, // The relative height of the text to display in the wave circle. 1 = 50%\r\n    // tslint:disable-next-line:max-line-length\r\n    valueCountUp: true, // If true, the displayed value counts up from 0 to it's final value upon loading. If false, the final value is displayed.\r\n    displayPercent: true, // If true, a % symbol is displayed after the value.\r\n\r\n    textColor: '#045681', // The color of the value text when the wave does not overlap it.\r\n    waveTextColor: '#A4DBf8' // The color of the value text when the wave overlaps it.\r\n  };\r\n}\r\n\r\nexport function loadLiquidFillGauge(elementId, value, config) {\r\n  if (config == null) {\r\n    config = liquidFillGaugeDefaultSettings();\r\n  }\r\n  const gauge = d3.select('#' + elementId);\r\n  const radius = Math.min(parseInt(gauge.style('width'), 10), parseInt(gauge.style('height'), 10)) / 2;\r\n  const locationX = parseInt(gauge.style('width'), 10) / 2 - radius;\r\n  const locationY = parseInt(gauge.style('height'), 10) / 2 - radius;\r\n  let fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;\r\n\r\n  let waveHeightScale;\r\n  if (config.waveHeightScaling) {\r\n    waveHeightScale = d3.scaleLinear()\r\n      .range([0, config.waveHeight, 0])\r\n      .domain([0, 50, 100]);\r\n  } else {\r\n    waveHeightScale = d3.scaleLinear()\r\n      .range([config.waveHeight, config.waveHeight])\r\n      .domain([0, 100]);\r\n  }\r\n\r\n  const textPixels = (config.textSize * radius / 2);\r\n  const textFinalValue = parseFloat(value).toFixed(2);\r\n  const textStartValue = config.valueCountUp ? config.minValue : textFinalValue;\r\n  const percentText = config.displayPercent ? '%' : '';\r\n  const circleThickness = config.circleThickness * radius;\r\n  const circleFillGap = config.circleFillGap * radius;\r\n  const fillCircleMargin = circleThickness + circleFillGap;\r\n  const fillCircleRadius = radius - fillCircleMargin;\r\n  let waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);\r\n\r\n  const waveLength = fillCircleRadius * 2 / config.waveCount;\r\n  const waveClipCount = 1 + config.waveCount;\r\n  const waveClipWidth = waveLength * waveClipCount;\r\n\r\n  // Rounding functions so that the correct number of decimal places is always displayed as the value counts up.\r\n  let textRounder = function (val) {\r\n    return '' + Math.round(val);\r\n  };\r\n  if (parseFloat(textFinalValue) !== parseFloat(textRounder(textFinalValue))) {\r\n    textRounder = function (val) {\r\n      return parseFloat(val).toFixed(1);\r\n    };\r\n  }\r\n  if (parseFloat(textFinalValue) !== parseFloat(textRounder(textFinalValue))) {\r\n    textRounder = function (val) {\r\n      return parseFloat(val).toFixed(2);\r\n    };\r\n  }\r\n\r\n  // Data for building the clip wave area.\r\n  const data = [];\r\n  for (let i = 0; i <= 40 * waveClipCount; i++) {\r\n    data.push({\r\n      x: i / (40 * waveClipCount),\r\n      y: (i / (40))\r\n    });\r\n  }\r\n\r\n  // Scales for drawing the outer circle.\r\n  const gaugeCircleX = d3.scaleLinear().range([0, 2 * Math.PI]).domain([0, 1]);\r\n  const gaugeCircleY = d3.scaleLinear().range([0, radius]).domain([0, radius]);\r\n\r\n  // Scales for controlling the size of the clipping path.\r\n  let waveScaleX = d3.scaleLinear().range([0, waveClipWidth]).domain([0, 1]);\r\n  let waveScaleY = d3.scaleLinear().range([0, waveHeight]).domain([0, 1]);\r\n\r\n  // Scales for controlling the position of the clipping path.\r\n  let waveRiseScale = d3.scaleLinear()\r\n    // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave\r\n    // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill\r\n    // circle at 100%.\r\n    .range([(fillCircleMargin + fillCircleRadius * 2 + waveHeight), (fillCircleMargin - waveHeight)])\r\n    .domain([0, 1]);\r\n  const waveAnimateScale = d3.scaleLinear()\r\n    .range([0, waveClipWidth - fillCircleRadius * 2]) // Push the clip area one full wave then snap back.\r\n    .domain([0, 1]);\r\n\r\n  // Scale for controlling the position of the text within the gauge.\r\n  const textRiseScaleY = d3.scaleLinear()\r\n    .range([fillCircleMargin + fillCircleRadius * 2, (fillCircleMargin + textPixels * 0.7)])\r\n    .domain([0, 1]);\r\n\r\n  // Center the gauge within the parent SVG.\r\n  const gaugeGroup = gauge.append('g')\r\n    .attr('transform', 'translate(' + locationX + ',' + locationY + ')');\r\n\r\n  // Draw the outer Rectangle.\r\n  var rectpoints = [{x: 0, y: 0}, {x: 0, y: parseInt(gauge.style('height'))}, {x: parseInt(gauge.style('width'), 10), y: parseInt(gauge.style('height'))}, {x: parseInt(gauge.style('width'), 10), y: 0}, {x: 0, y: 0}];\r\n  var lineFunc = d3.line()\r\n      .x(function(d) { return d.x })\r\n      .y(function(d) { return d.y });\r\n  gaugeGroup.append('path')\r\n    .attr('d', lineFunc(rectpoints))\r\n    .attr('stroke', config.circleColor)\r\n    .attr('stroke-width', circleThickness)\r\n    .attr('fill', 'none');\r\n\r\n  // Text where the wave does not overlap.\r\n  const text1 = gaugeGroup.append('text')\r\n    .text(textRounder(textStartValue) + percentText)\r\n    .attr('class', 'liquidFillGaugeText')\r\n    .attr('text-anchor', 'middle')\r\n    .attr('font-size', textPixels + 'px')\r\n    .style('fill', config.textColor)\r\n    .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');\r\n\r\n  // The clipping wave area.\r\n  const clipArea = d3.area()\r\n    .x(function (d: any) {\r\n      return waveScaleX(d.x);\r\n    })\r\n    .y0(function (d: any) {\r\n      return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (1 - config.waveCount) + d.y * 2 * Math.PI));\r\n    })\r\n    .y1(function (d) {\r\n      return (fillCircleRadius * 2 + waveHeight);\r\n    });\r\n  const waveGroup = gaugeGroup.append('defs')\r\n    .append('clipPath')\r\n    .attr('id', 'clipWave' + elementId);\r\n  const wave = waveGroup.append('path')\r\n    .datum(data)\r\n    .attr('d', clipArea)\r\n    .attr('T', 0);\r\n\r\n  // The inner circle with the clipping wave attached.\r\n  const fillCircleGroup = gaugeGroup.append('g')\r\n    .attr('clip-path', 'url(#clipWave' + elementId + ')');\r\n  fillCircleGroup.append('rect')\r\n        .attr('x', (radius) - fillCircleRadius)\r\n        .attr('y', radius - fillCircleRadius)\r\n        .attr('width', fillCircleRadius*2)\r\n        .attr('height', fillCircleRadius*2)\r\n        .style('fill', config.waveColor);\r\n\r\n  // Text where the wave does overlap.\r\n  const text2 = fillCircleGroup.append('text')\r\n    .text(textRounder(textStartValue) + percentText)\r\n    .attr('class', 'liquidFillGaugeText')\r\n    .attr('text-anchor', 'middle')\r\n    .attr('font-size', textPixels + 'px')\r\n    .style('fill', config.waveTextColor)\r\n    .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');\r\n\r\n  // Make the value count up.\r\n  if (config.valueCountUp) {\r\n    const textTween = function g() {\r\n      const i = d3.interpolate(this.textContent, textFinalValue);\r\n      return (t) => {\r\n        this.textContent = textRounder(i(t)) + percentText;\r\n      };\r\n    };\r\n    text1.transition()\r\n      .duration(config.waveRiseTime)\r\n      .tween('text', textTween);\r\n    text2.transition()\r\n      .duration(config.waveRiseTime)\r\n      .tween('text', textTween);\r\n  }\r\n\r\n  // Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.\r\n  const waveGroupXPosition = fillCircleMargin + fillCircleRadius * 2 - waveClipWidth;\r\n  if (config.waveRise) {\r\n\r\n    waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(0) + ')')\r\n      .transition()\r\n      .duration(config.waveRiseTime)\r\n      .attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')')\r\n      .on('start', () => {\r\n        wave.attr('transform', 'translate(1,0)');\r\n      }); // This transform is necessary to get the clip wave positioned correctly when waveRise=true and\r\n    // waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.\r\n  } else {\r\n    waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')');\r\n  }\r\n\r\n  if (config.waveAnimate) {\r\n    animateWave();\r\n  }\r\n\r\n  function animateWave(_?: any) {\r\n    wave.attr('transform', 'translate(' + waveAnimateScale(+wave.attr('T')) + ',0)');\r\n    wave.transition()\r\n      .duration(config.waveAnimateTime * (1 - +wave.attr('T')))\r\n      .ease(d3.easeLinear)\r\n      .attr('transform', 'translate(' + waveAnimateScale(1) + ',0)')\r\n      .attr('T', 1)\r\n      .on('end', () => {\r\n        wave.attr('T', 0);\r\n        animateWave(config.waveAnimateTime);\r\n      });\r\n  }\r\n\r\n  function GaugeUpdater() {\r\n    this.update = function (val) {\r\n      const newFinalValue = parseFloat(val).toFixed(2);\r\n      let textRounderUpdater = function (val2) {\r\n        return '' + Math.round(val2);\r\n      };\r\n      if (parseFloat(newFinalValue) !== parseFloat(textRounderUpdater(newFinalValue))) {\r\n        textRounderUpdater = function (val2) {\r\n          return parseFloat(val2).toFixed(1);\r\n        };\r\n      }\r\n      if (parseFloat(newFinalValue) !== parseFloat(textRounderUpdater(newFinalValue))) {\r\n        textRounderUpdater = function (val2) {\r\n          return parseFloat(val2).toFixed(2);\r\n        };\r\n      }\r\n\r\n      const textTween = () => {\r\n        const i = d3.interpolate(this.textContent, parseFloat(value).toFixed(2));\r\n        return function (t) {\r\n          this.textContent = textRounderUpdater(i(t)) + percentText;\r\n        };\r\n      };\r\n\r\n      text1.transition()\r\n        .duration(config.waveRiseTime)\r\n        .tween('text', textTween);\r\n      text2.transition()\r\n        .duration(config.waveRiseTime)\r\n        .tween('text', textTween);\r\n\r\n      fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;\r\n      waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);\r\n      waveRiseScale = d3.scaleLinear()\r\n        // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave\r\n        // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill\r\n        // circle at 100%.\r\n        .range([(fillCircleMargin + fillCircleRadius * 2 + waveHeight), (fillCircleMargin - waveHeight)])\r\n        .domain([0, 1]);\r\n      const newHeight = waveRiseScale(fillPercent);\r\n      waveScaleX = d3.scaleLinear().range([0, waveClipWidth]).domain([0, 1]);\r\n      waveScaleY = d3.scaleLinear().range([0, waveHeight]).domain([0, 1]);\r\n      let newClipArea;\r\n      if (config.waveHeightScaling) {\r\n        newClipArea = d3.area()\r\n          .x((d: any) => {\r\n            return waveScaleX(d.x);\r\n          })\r\n          .y0((d: any) => {\r\n            return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (1 - config.waveCount) + d.y * 2 * Math.PI));\r\n          })\r\n          .y1((d) => {\r\n            return (fillCircleRadius * 2 + waveHeight);\r\n          });\r\n      } else {\r\n        newClipArea = clipArea;\r\n      }\r\n\r\n      const newWavePosition = config.waveAnimate ? waveAnimateScale(1) : 0;\r\n      wave.transition()\r\n        .duration(0)\r\n        .transition()\r\n        .duration(config.waveAnimate ? (config.waveAnimateTime * (1 - +wave.attr('T'))) : (config.waveRiseTime))\r\n        .ease(d3.easeLinear)\r\n        .attr('d', newClipArea)\r\n        .attr('transform', 'translate(' + newWavePosition + ',0)')\r\n        .attr('T', '1')\r\n        .on('start', () => {\r\n          if (config.waveAnimate) {\r\n            wave.attr('transform', 'translate(' + waveAnimateScale(0) + ',0)');\r\n            animateWave(config.waveAnimateTime);\r\n          }\r\n        });\r\n      waveGroup.transition()\r\n        .duration(config.waveRiseTime)\r\n        .attr('transform', 'translate(' + waveGroupXPosition + ',' + newHeight + ')');\r\n    };\r\n  }\r\n\r\n  return new GaugeUpdater();\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { NgxLiquidGaugeComponent } from './ngx-liquid-gauge.component';\r\n\r\n@NgModule({\r\n  imports: [\r\n  ],\r\n  declarations: [NgxLiquidGaugeComponent],\r\n  exports: [NgxLiquidGaugeComponent]\r\n})\r\nexport class NgxLiquidGaugeModule { }\r\n"]}